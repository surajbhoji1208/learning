1	What is Nestjs?
=>   Nest(NestJS) is a framework for building efficient, scalable Node.js server side applications.
     It uses progressive JavaScript and its built with and fully suports Typescript.


7	What are the main components of a NestJS application?
=>   The main contents of the nestjs application inlcude: Modules: Modules are a way of organizing related components into a single block. They provide a way to structure your application.
     Controllers: Controllers are responsible for handling incoming requests and returning responses to the client.Controllers organize routes and handle HTTP requests that come to those routes.
     Services: services are responsible for business logic and interacting with data sources. They can be injected into controllers or other services, promoting code reusability and separation of concerns.

9	Can you explain how to use decorators in a NestJS controller?
=>   Before explaining how to use decorators, let me explain more about what are decorators:
     decorators are special functions that are prefixed with an @ symbol and can be attached to classes, methods, or properties. They are used to add metadata, methods, properties, or observe the behavior of the classes, methods, or properties they are attached to.
     NestJS provides several built-in decorators, and you can also create custom decorators. Here are some examples of built-in decorators in NestJS:
     Class decorators like @Controller(), @Module(), @Injectable(), etc. These are used to annotate classes.
     Method decorators like @Get(), @Post(), @Put(), etc. These are used to annotate methods within controller classes to handle specific routes.
     Parameter decorators like @Req(), @Res(), @Body(), etc. These are used to annotate parameters within route handling methods.
     Property decorators like @Inject(). These are used to annotate properties within classes.
     Custom decorators. You can create your own decorators to handle common tasks across your application.
     For example, below is how method decorators are used to handle GET, POST, PUT, DELETE requests respectively.

                    import {Controller,Get,Param,Body,Post,Patch,Delete,} from "@nestjs/common";

                    @Controller("cats")
                    export class CatsController {
                         @Get()
                         findAll(): string {
                         return "This action returns all cats";
                         }

                         @Get(":id")
                         findOne(@Param("id") id: number): string {
                         return `This action returns a cat with the provided id`;
                         }

                         @Post()
                         create(@Body() body: any): string {
                         return `This action returns the body of the cat`;
                         }

                         @Patch("id")
                         update(@Param("id") id: number, @Body() body: any): string {
                         return `This action updates the body of the cat`;
                         }

                         @Delete("id")
                         remove(@Param("id") id: number): string {
                         return `This action removes a cat`;
                         }
                    }

10	How can you use route parameters in a NestJS controller?
=>   Route parameters in a NestJS controller can be accessed using the @Param() decorator in the controller methods.
               @Patch('id')
               update(@Param('id') id: number, @Body() body: any ): string {
                    return `This action updates the body of the cat`;
               }

11	What is the role of the @Body() decorator?
=>   The @Body() decorator in NestJS is used to extract the entire body of the incoming HTTP request.

12	What is an interceptor in the context of NestJS?
=>   An interceptor is a class annotated with the @Injectable() decorator and implements the NestInterceptor interface.
     An Interceptor is function that can be used to intercept incoming requests to a NestJS application and perform some sort of manipulation before the request is handled by the route handler. This can be useful for things like logging, authentication and so on.
     Binding extra logic before / after method execution: An Interceptor can execute logic before and after a method is executed. This can be useful for tasks like logging, transforming the result of a method, or handling errors.
     Transforming the result returned from a function: An Interceptor can transform the response returned from a method. For example, you could use an interceptor to transform all responses to have a specific format.
     Handling errors: An Interceptor can also handle errors thrown within your application. This can be useful for logging or transforming errors before they're sent to the client. Here is an example of an interceptor that logs the user interactions as shown in the Nestjs document

               import {Injectable,NestInterceptor,ExecutionContext,CallHandler,} from "@nestjs/common";
               import { Observable } from "rxjs";
               import { tap } from "rxjs/operators";

               @Injectable()
               export class LoggingInterceptor implements NestInterceptor {
                    intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
                    console.log("Before...");

                    const now = Date.now();
                    return next
                         .handle()
                         .pipe(tap(() => console.log(`After... ${Date.now() - now}ms`)));
                    }
               }

13	What are pipes in the context of NestJS?
     =>In NestJS, Pipes are classes used to transform and validate incoming request data before it reaches the route handler.
       They run after the request is received but before the controller method is executed.
          In NestJS, Pipes are classes used to transform and validate incoming request data before it reaches the route handler.
               They run after the request is received but before the controller method is executed.
               Pipes serve two main purposes:
               1ï¸âƒ£ Validation
               Validate incoming data (DTOs).
               If validation fails, Pipes throw an exception automatically.
               2ï¸âƒ£ Transformation
               Convert input data into the required format (e.g., string â†’ number).

                     @Post()
                    createUser(@Body(new ValidationPipe()) body: CreateUserDto) {
                    return body;
                    }

                    @Get(':id')
                    getUser(@Param('id', ParseIntPipe) id: number) {
                    return id;
                    }


14	What are guards in the context of NestJS?
=>   Guards are classes used to control whether a request should be allowed to proceed to a route handler.
      They are mainly responsible for authentication and authorization,
          import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
          @Injectable()
          export class AuthGuard implements CanActivate {
          canActivate(context: ExecutionContext): boolean {
          const request = context.switchToHttp().getRequest();
          return Boolean(request.headers.authorization); // simple example
          }
          }

15	What are middlewares in the context of NestJS?
=>   Middleware are functions that run before your route handlers and even before guards, interceptors, and pipes.
     They sit early in the request lifecycle and are typically used for tasks like logging, authentication checks,
     modifying the request/response objects, or running custom logic before the request reaches the controller.

16	Explain the concept of Dependency Injection in NestJS. How does it help in building modular and testable applications?
=>Dependency Injection (DI) in NestJS is a design pattern where the framework automatically provides the required dependencies (services, repositories, etc.) to classes instead of you creating them manually.
     When a class needs that provider, NestJS automatically injects it through the constructor.
     ðŸ’¡ How Dependency Injection Works in NestJS
     You create a provider (service, repo, etc.).
     You register the provider inside a module.
     NestJS stores providers in the IoC container.

     How DI Helps Build Modular Applications
          1ï¸âƒ£ Loosely Coupled Architecture
          Classes donâ€™t manage their own dependencies â†’ components depend on abstractions, not implementations.
          â†’ Code is easier to modify or extend.
          2ï¸âƒ£ Reusability
          A single service can be injected into multiple modules, controllers, or other services.
          â†’ No duplication, more maintainable code.

17	Whatâ€™s the difference between @injectable() and @inject() decorators?
=> 1. @Injectable() â€” Marks a Class as a Provider
     @Injectable() is placed on top of a class to tell NestJS that this class can be managed by the dependency injection (DI) container.
     âœ” Makes the class a provider
     âœ” Allows NestJS to create an instance
     âœ” Enables NestJS to inject this provider into other classes
   2.@Inject() is used when you inject a provider that doesnâ€™t have a class type, such as a provider defined using useValue, useFactory, or a custom string/token.
     NestJS cannot auto-resolve these, so @Inject() tells Nest exactly which provider token to use
     PROVIDER
                    {
               provide: 'DATABASE_CONNECTION',
                    useFactory: async () => {
                    return await createConnection({
                         host: 'localhost',
                         port: 5432,
                         database: 'test',
                    });
                    }
               }
     Injecting it:
               constructor(
                    @Inject('DATABASE_CONNECTION') 
                    private readonly dbConnection
                    ) {}



18	How does the Nest logger differ from the standard console.log() and when would you prefer one over the other?
=>NestJS provides a built-in Logger class that gives structured, controlled, and contextual logging, unlike plain console.log(), which is just raw output.
  Nest Logger adds timestamps & context automatically

19	What is the difference between interceptors and middleware,pipe gruard?
=>1. Middleware
          âœ” What it is
               Functions that run before the request enters NestJS route handlers.
               Similar to Express middleware.
               Lowest-level request processing layer.
          âœ” When it runs
               Before Guards, Interceptors, Pipes, Controllers.
               Very early in the request pipeline.
          âœ” What it can do
               Modify request (req) or response (res)
               Perform logging or request validation
               Call next() to pass control
               Stop request early (e.g., deny access)
               Add metadata to request object
          âœ” Common Use Cases
               Logging incoming HTTP requests
               CORS, rate limiting
               Basic auth (API key check)
               Parsing custom headers
               Adding request IDs
          âœ” Limitations
               Cannot transform response
               Not tied to Nestâ€™s DI lifecycle (Express-level)

     ðŸŸ§ 2. Guards
          âœ” What it is
               Classes that decide whether the request can proceed.
               Used for authorization and conditional access.
          âœ” When it runs
               After middleware
               Before interceptors and pipes
          âœ” What it can do
               Allow or block a request by returning true or false
               Throw exceptions to stop flow
               Access ExecutionContext (request metadata)
          âœ” Common Use Cases
               Role-based access (AdminGuard)
               Permission checks
               JWT authentication (validate token)
               Feature flag checks
          âœ” Limitations
               Cannot modify or transform the response
               Not meant for request transformation
               Not for heavy business logic

     ðŸŸ© 3. Interceptors
          âœ” What it is
               A â€œwrapperâ€ around the controller method.
               Runs before and after the controller.
               Very powerful â€” can transform results or catch responses.
          âœ” When it runs
               After guards
               Before the controller (pre-processing)
               After the controller (post-processing)
          âœ” What it can do
               Transform response (most important!)
               Apply mapping logic (e.g., wrap all responses in { data: ... })
               Add logging/timing for performance
               Implement caching
               Modify returned observables
          âœ” Common Use Cases
               Transforming API responses
               Request/response logging
               Measuring execution time
               Caching responses
               Binding extra logic around method execution
          âœ” Limitations
               Cannot change the raw request body like middleware
               Works at Nest layer, not Express lowÂ­-level

     ðŸŸª 4. Pipes
          âœ” What it is
               Functions that validate or transform incoming data.
               Specially designed for validation and parsing.
          âœ” When it runs
               After Guards
               Before Controller handler
               On method parameters (DTOs)
          âœ” What it can do
               Validate incoming payload (class-validator)
               Transform types (string â†’ number)
               Clean incoming data


21	Explain the purpose of DTOs (Data Transfer Objects) in NestJS.
=>A DTO (Data Transfer Object) is a TypeScript class used to define the shape, structure, and validation rules of incoming data â€” usually for:
     HTTP request bodies
     Query parameters
     Route parameters

23	Explain the purpose of the @InjectRepository() decorator in NestJS.
=>@InjectRepository() is a decorator used in NestJS (with TypeORM) to inject a database repository into your service using Nestâ€™s Dependency Injection system.
     Instead of manually creating a database connection, Nest and TypeORM handle i
     A Repository in TypeORM is the object that gives you methods like:
     find()
     findOne()
     save()
     update()
     delete()
     custom queries
     So @InjectRepository() allows you to access the database table/entity inside your service.

30	What are custom providers and how do they differ from standard Providers in Nest.js?
=>   A provider is any class or value that NestJS can manage and inject using its Dependency Injection (DI) system
     Custom providers are providers where you explicitly define how the dependency is created or resolved, instead of letting NestJS instantiate a class automatically.
     Custom providers use an object-based syntax with provide and one of:
          useClass
          useValue
          useFactory
          useExisting


35	What is the purpose of the @nestjs/passport package, and how does it facilitate authentication in NestJS?
=>   passport.js is node js popular middleware library but its not titly inegrated with nest js DI and decorator
     :. nest/passport comes in pitchure 
          wrap passport into nest js guards
          integrated with nest js DI
          provide clean stable and scalable authentication
           High-Level Flow
               Client sends request with credentials/token
               AuthGuard intercepts the request
               Passport strategy validates the credentials
               Valid user is attached to request.user
               Controller receives authenticated request

36	How can you handle file uploads in NestJS, and what is the role of the Multer library?
=> Multer is a Node.js middleware for handling multipart/form-data, which is primarily used for file uploads.
     NestJS uses Multer internally to handle file uploads in a clean, decorator-based way.
     npm install @nestjs/platform-express multer

38	What is Circular dependency (dependency cycle) in Nestjs, and how can they be fixed?
=>A circular dependency occurs when two or more providers/modules depend on each other directly or indirectly, creating a dependency loop that NestJS cannot resolve automatically.
     NestJS DI container cannot determine which dependency to create first
     Leads to runtime errors or undefined injections
          Ways to Fix Circular Dependencies
               Use forwardRef() (Most Common Fix)
               Refactor Shared Logic into a Separate Service
          
39	How can you handle errors in NestJS?
=>   NestJS provides a structured and centralized error-handling system built on top of Node.js
     eg BadRequestException

40	How does NestJS handle CORS (Cross-Origin Resource Sharing)?
=>   cors is mechanisum where one domain or ip can use Resource of other domain
     cors is desable by defauld in nest js
     
41	Explain the purpose of the ExecutionContext in NestJS Middleware?
42	How can you implement soft deletes in NestJS using TypeORM, and why might soft deletes be preferred over hard deletes?
43	Explain the concept of environment variables in NestJS, and how can they be utilized for configuration management?
44	What is the role of migration scripts in TypeORM, and how can you create and run migrations in a NestJS application?
45	What is the purpose of ExecutionContext in NestJS?
46	What is the purpose of the @Res() decorator in NestJS controllers?
47	Explain the various Modules in NestJS?
48	How can you secure your NestJS application?
49	What is the entry file of NestJs application?
50	What is the difference between dependency injection and inversion of control (IoC)?
51	How can you implement Caching in NestJS?
52	Explain the purpose of the Dependency Inversion Principle (DIP) in NestJS?
53	How can you schedule tasks in NestJS?
54	How can you handle database transactions in NestJS, and why are transactions important in certain scenarios?
55	How can you implement versioning in NestJS APIs?
56	Explain the purpose of the @nestjs/graphql Resolver and @nestjs/graphql Scalar decorators, and how they relate to GraphQL in NestJS?
57	Explain the concept of Serialization and Deserialization in NestJS?
58	Explain the role of NestJS middleware in the context of Microservices and provide a scenario where middleware is beneficial in a Microservices setup?
59	Discuss the different types of coupling, such as tight coupling and loose coupling, and provide examples of how NestJS modules contribute to achieving loose coupling in a modularized application?
60	How does NestJS support Server-Sent Events (SSE), and what are the primary advantages of using SSE for real-time communication in web applications?